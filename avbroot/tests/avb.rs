// SPDX-FileCopyrightText: 2023-2024 Andrew Gunnerson
// SPDX-License-Identifier: GPL-3.0-only

use std::{
    io::{Cursor, Read, Seek, Write},
    sync::atomic::AtomicBool,
};

use assert_matches::assert_matches;
use pkcs8::DecodePrivateKey;
use rsa::RsaPrivateKey;

use avbroot::{
    self,
    crypto::RsaSigningKey,
    format::avb::{
        self, AlgorithmType, AppendedDescriptorMut, AppendedDescriptorRef,
        ChainPartitionDescriptor, Descriptor, Footer, HashDescriptor, HashTreeDescriptor, Header,
        KernelCmdlineDescriptor, PropertyDescriptor,
    },
    stream::SharedCursor,
};

fn get_test_key() -> RsaSigningKey {
    let data = include_str!(concat!(
        env!("CARGO_WORKSPACE_DIR"),
        "/e2e/keys/TEST_KEY_DO_NOT_USE_avb.key",
    ));
    let passphrase = include_str!(concat!(
        env!("CARGO_WORKSPACE_DIR"),
        "/e2e/keys/TEST_KEY_DO_NOT_USE_avb.passphrase",
    ));

    let key = RsaPrivateKey::from_pkcs8_encrypted_pem(data, passphrase.trim_end()).unwrap();
    RsaSigningKey::Internal(key)
}

fn repeat_str(s: &str, max_len: usize) -> String {
    assert!(!s.is_empty());

    let mut result = s.repeat(max_len / s.len());
    result.push_str(&s[..max_len % s.len()]);

    result
}

fn repeat_array<const N: usize>(data: &[u8]) -> [u8; N] {
    assert!(!data.is_empty());

    let mut result = [0u8; N];

    for i in 0..N / data.len() {
        result[i * data.len()..][..data.len()].copy_from_slice(data);
    }

    let remain = N % data.len();
    result[N - remain..].copy_from_slice(&data[..remain]);

    result
}

#[test]
fn round_trip_root_image() {
    let mut header = Header {
        required_libavb_version_major: 1,
        required_libavb_version_minor: 0,
        algorithm_type: AlgorithmType::Sha256Rsa4096,
        hash: vec![],       // autogenerated
        signature: vec![],  // autogenerated
        public_key: vec![], // autogenerated
        public_key_metadata: vec![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ],
        descriptors: vec![
            Descriptor::Property(PropertyDescriptor {
                key: "foobar".to_owned(),
                value: b"Invalid UTF-8: \xFF".to_vec(),
            }),
            Descriptor::HashTree(HashTreeDescriptor {
                dm_verity_version: 1,
                image_size: 4096,
                tree_offset: 0,
                tree_size: 2048,
                data_block_size: 4096,
                hash_block_size: 4096,
                fec_num_roots: 1,
                fec_offset: 2048,
                fec_size: 2048,
                hash_algorithm: "sha512".to_owned(),
                partition_name: "hashtreed_partition".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(8),
                root_digest: [0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10].repeat(8),
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
            Descriptor::Hash(HashDescriptor {
                image_size: 6,
                hash_algorithm: "sha256".to_owned(),
                partition_name: "hashed_partition".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(4),
                root_digest: [0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10].repeat(4),
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
            Descriptor::KernelCmdline(KernelCmdlineDescriptor {
                flags: 1,
                cmdline: "foobar".to_owned(),
            }),
            Descriptor::ChainPartition(ChainPartitionDescriptor {
                rollback_index_location: 1,
                partition_name: "chained_partition".to_owned(),
                public_key: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(129),
                flags: 0xfedcba98,
                reserved: repeat_array(&[0x76, 0x54, 0x32, 0x10, 0xfe, 0xdc, 0xba, 0x98]),
            }),
        ],
        rollback_index: 1677974400,
        flags: 0,
        rollback_index_location: 0,
        release_string: repeat_str("MaxLength", 47),
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };

    // Sign the header.
    let key = get_test_key();
    header.sign(&key).unwrap();
    assert_eq!(header.verify().unwrap().unwrap(), key.to_public_key());

    // Write vbmeta structures.
    let mut writer = Cursor::new(Vec::new());
    avb::write_root_image(&mut writer, &header, 64).unwrap();
    let data = writer.into_inner();

    // Verify checksum of the output.
    assert_eq!(
        aws_lc_rs::digest::digest(&aws_lc_rs::digest::SHA512, &data).as_ref(),
        [
            0x3b, 0x01, 0xf6, 0x04, 0x04, 0x6e, 0x6f, 0x60, 0x9c, 0xb0, 0x8b, 0x8a, 0x43, 0xf7,
            0x91, 0x2e, 0xc4, 0x1b, 0xc0, 0x7f, 0xa1, 0xe4, 0xe6, 0x59, 0x14, 0x08, 0xbe, 0x83,
            0xae, 0x0a, 0x0f, 0x0a, 0x4a, 0x15, 0x91, 0x0e, 0x4d, 0x18, 0x31, 0x48, 0x20, 0xe8,
            0x44, 0x62, 0x07, 0x98, 0x43, 0x30, 0xee, 0x2d, 0x20, 0x28, 0xc3, 0x94, 0xc6, 0x0e,
            0x86, 0xa3, 0xa7, 0x17, 0x36, 0xfd, 0x50, 0x7c,
        ],
    );

    // Parse the generated image.
    let mut reader = Cursor::new(&data);
    let (new_header, new_footer, new_image_size) = avb::load_image(&mut reader).unwrap();
    assert_matches!(new_footer, None);

    assert_eq!(new_header, header);
    assert_eq!(new_image_size, data.len() as u64);
}

#[test]
fn round_trip_appended_hash_image() {
    let image_size = 12288;
    let raw_data = b"foobar";
    let mut header = Header {
        required_libavb_version_major: 1,
        required_libavb_version_minor: 0,
        algorithm_type: AlgorithmType::Sha256Rsa4096,
        hash: vec![],       // autogenerated
        signature: vec![],  // autogenerated
        public_key: vec![], // autogenerated
        public_key_metadata: vec![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ],
        descriptors: vec![
            Descriptor::Property(PropertyDescriptor {
                key: "foobar".to_owned(),
                value: b"Invalid UTF-8: \xFF".to_vec(),
            }),
            Descriptor::Hash(HashDescriptor {
                image_size: raw_data.len() as u64,
                hash_algorithm: "sha256".to_owned(),
                partition_name: "vbmeta_appended_hash".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(4),
                root_digest: vec![], // autogenerated
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
        ],
        rollback_index: 1677974400,
        flags: 0,
        rollback_index_location: 0,
        release_string: repeat_str("MaxLength", 47),
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };
    let mut footer = Footer {
        version_major: 1,
        version_minor: 0,
        original_image_size: 0, // autogenerated
        vbmeta_offset: 0,       // autogenerated
        vbmeta_size: 0,         // autogenerated
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };

    let mut writer = Cursor::new(Vec::new());
    let cancel_signal = AtomicBool::new(false);

    // Write the raw partition data.
    writer.write_all(raw_data).unwrap();

    // Regenerate the raw image digest.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(_) => panic!("Expected hash descriptor"),
        AppendedDescriptorMut::Hash(d) => {
            writer.rewind().unwrap();
            d.update(&mut writer, &cancel_signal).unwrap();
        }
    }

    // Verify the raw image digest.
    match header.appended_descriptor().unwrap() {
        AppendedDescriptorRef::HashTree(_) => panic!("Expected hash descriptor"),
        AppendedDescriptorRef::Hash(d) => {
            writer.rewind().unwrap();
            d.verify(&mut writer, &cancel_signal).unwrap();
        }
    }

    // Sign the header.
    let key = get_test_key();
    header.sign(&key).unwrap();
    assert_eq!(header.verify().unwrap().unwrap(), key.to_public_key());

    // Write vbmeta structures.
    avb::write_appended_image(&mut writer, &header, &mut footer, Some(image_size)).unwrap();
    let data = writer.into_inner();

    // Verify checksum of the output.
    assert_eq!(
        aws_lc_rs::digest::digest(&aws_lc_rs::digest::SHA512, &data).as_ref(),
        [
            0x91, 0x38, 0x61, 0xc0, 0x68, 0x2a, 0x8b, 0xd8, 0x01, 0xa6, 0xe4, 0x4c, 0x1d, 0x27,
            0x93, 0x1b, 0xa4, 0x63, 0xd1, 0xbb, 0xf1, 0x64, 0x05, 0xf2, 0xa1, 0xa0, 0xb3, 0x35,
            0xe1, 0xc5, 0xac, 0x4f, 0x98, 0xb3, 0x0a, 0xed, 0xfc, 0xee, 0xa2, 0x6a, 0x77, 0xf4,
            0xe5, 0x69, 0xa0, 0xcd, 0x7a, 0xd1, 0xfe, 0x1d, 0x07, 0xd1, 0x25, 0xc6, 0x22, 0xe0,
            0x25, 0xcb, 0xe9, 0x75, 0x50, 0xe4, 0xae, 0x59,
        ],
    );

    // Parse the generated image.
    let mut reader = Cursor::new(&data);
    let (new_header, new_footer, new_image_size) = avb::load_image(&mut reader).unwrap();
    let new_footer = new_footer.unwrap();

    assert_eq!(new_header, header);
    assert_eq!(new_footer, footer);
    assert_eq!(new_image_size, image_size);
}

#[test]
fn round_trip_appended_hash_tree_image_fixed_size() {
    let image_size = 32768;
    let raw_data: [u8; 8192] = repeat_array(b"foobar");
    let mut header = Header {
        required_libavb_version_major: 1,
        required_libavb_version_minor: 0,
        algorithm_type: AlgorithmType::Sha256Rsa4096,
        hash: vec![],       // autogenerated
        signature: vec![],  // autogenerated
        public_key: vec![], // autogenerated
        public_key_metadata: vec![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ],
        descriptors: vec![
            Descriptor::Property(PropertyDescriptor {
                key: "foobar".to_owned(),
                value: b"Invalid UTF-8: \xFF".to_vec(),
            }),
            Descriptor::HashTree(HashTreeDescriptor {
                dm_verity_version: 1,
                image_size: raw_data.len() as u64,
                tree_offset: 0, // autogenerated
                tree_size: 0,   // autogenerated
                data_block_size: 4096,
                hash_block_size: 4096,
                fec_num_roots: 2,
                fec_offset: 0, // autogenerated
                fec_size: 0,   // autogenerated
                hash_algorithm: "sha256".to_owned(),
                partition_name: "vbmeta_appended_hash_tree".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(4),
                root_digest: vec![], // autogenerated
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
        ],
        rollback_index: 1677974400,
        flags: 0,
        rollback_index_location: 0,
        release_string: repeat_str("MaxLength", 47),
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };
    let mut footer = Footer {
        version_major: 1,
        version_minor: 0,
        original_image_size: 0, // autogenerated
        vbmeta_offset: 0,       // autogenerated
        vbmeta_size: 0,         // autogenerated
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };

    let mut writer = SharedCursor::default();
    let cancel_signal = AtomicBool::new(false);

    // Write the raw partition data.
    writer.write_all(&raw_data).unwrap();

    // Generate and write the hash tree and FEC data.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(d) => {
            d.update(&writer, &writer, None, &cancel_signal).unwrap();
        }
        AppendedDescriptorMut::Hash(_) => panic!("Expected hash tree descriptor"),
    }

    // Verify the hash tree and FEC data.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(d) => {
            d.verify(&writer, &cancel_signal).unwrap();
        }
        AppendedDescriptorMut::Hash(_) => panic!("Expected hash tree descriptor"),
    }

    // Sign the header.
    let key = get_test_key();
    header.sign(&key).unwrap();
    assert_eq!(header.verify().unwrap().unwrap(), key.to_public_key());

    // Write vbmeta structures.
    avb::write_appended_image(&mut writer, &header, &mut footer, Some(image_size)).unwrap();
    let mut data = Vec::new();
    writer.rewind().unwrap();
    writer.read_to_end(&mut data).unwrap();

    // Verify checksum of the output.
    assert_eq!(
        aws_lc_rs::digest::digest(&aws_lc_rs::digest::SHA512, &data).as_ref(),
        [
            0x92, 0xdd, 0x4d, 0xc5, 0xb0, 0x5b, 0x4f, 0x65, 0x97, 0x5a, 0x72, 0x66, 0xde, 0x82,
            0xc2, 0x2f, 0x33, 0x86, 0x8b, 0x65, 0x67, 0x80, 0x1d, 0xca, 0xd6, 0x2c, 0xfc, 0xca,
            0xaf, 0x4c, 0x56, 0x64, 0x3a, 0xd1, 0x06, 0x01, 0xda, 0x2e, 0x05, 0x67, 0xd1, 0x01,
            0xe3, 0xcb, 0x7b, 0x1e, 0xeb, 0x05, 0x89, 0xeb, 0x80, 0xcc, 0x17, 0x0c, 0x24, 0x73,
            0x0d, 0xcb, 0x36, 0xfa, 0x17, 0xbd, 0x20, 0x7e,
        ],
    );

    // Parse the generated image.
    let mut reader = Cursor::new(&data);
    let (new_header, new_footer, new_image_size) = avb::load_image(&mut reader).unwrap();
    let new_footer = new_footer.unwrap();

    assert_eq!(new_header, header);
    assert_eq!(new_footer, footer);
    assert_eq!(new_image_size, image_size);
}

#[test]
fn round_trip_appended_hash_tree_image_minimum_size() {
    let raw_data: [u8; 8192] = repeat_array(b"foobar");
    let mut header = Header {
        required_libavb_version_major: 1,
        required_libavb_version_minor: 0,
        algorithm_type: AlgorithmType::Sha256Rsa4096,
        hash: vec![],       // autogenerated
        signature: vec![],  // autogenerated
        public_key: vec![], // autogenerated
        public_key_metadata: vec![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ],
        descriptors: vec![
            Descriptor::Property(PropertyDescriptor {
                key: "foobar".to_owned(),
                value: b"Invalid UTF-8: \xFF".to_vec(),
            }),
            Descriptor::HashTree(HashTreeDescriptor {
                dm_verity_version: 1,
                image_size: raw_data.len() as u64,
                tree_offset: 0, // autogenerated
                tree_size: 0,   // autogenerated
                data_block_size: 4096,
                hash_block_size: 4096,
                fec_num_roots: 2,
                fec_offset: 0, // autogenerated
                fec_size: 0,   // autogenerated
                hash_algorithm: "sha256".to_owned(),
                partition_name: "vbmeta_appended_hash_tree".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(4),
                root_digest: vec![], // autogenerated
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
        ],
        rollback_index: 1677974400,
        flags: 0,
        rollback_index_location: 0,
        release_string: repeat_str("MaxLength", 47),
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };
    let mut footer = Footer {
        version_major: 1,
        version_minor: 0,
        original_image_size: 0, // autogenerated
        vbmeta_offset: 0,       // autogenerated
        vbmeta_size: 0,         // autogenerated
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };

    let mut writer = SharedCursor::default();
    let cancel_signal = AtomicBool::new(false);

    // Write the raw partition data.
    writer.write_all(&raw_data).unwrap();

    // Generate and write the hash tree and FEC data.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(d) => {
            d.update(&writer, &writer, None, &cancel_signal).unwrap();
        }
        AppendedDescriptorMut::Hash(_) => panic!("Expected hash tree descriptor"),
    }

    // Verify the hash tree and FEC data.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(d) => {
            d.verify(&writer, &cancel_signal).unwrap();
        }
        AppendedDescriptorMut::Hash(_) => panic!("Expected hash tree descriptor"),
    }

    // Sign the header.
    let key = get_test_key();
    header.sign(&key).unwrap();
    assert_eq!(header.verify().unwrap().unwrap(), key.to_public_key());

    // Write vbmeta structures.
    avb::write_appended_image(&mut writer, &header, &mut footer, None).unwrap();
    let mut data = Vec::new();
    writer.rewind().unwrap();
    writer.read_to_end(&mut data).unwrap();

    // Verify checksum of the output.
    assert_eq!(
        aws_lc_rs::digest::digest(&aws_lc_rs::digest::SHA512, &data).as_ref(),
        [
            0xcf, 0x6b, 0x90, 0xcf, 0x77, 0x76, 0x62, 0x12, 0xc2, 0x22, 0xe6, 0xd5, 0x5b, 0xab,
            0x82, 0xd8, 0x6c, 0x93, 0xa3, 0x35, 0x5b, 0x77, 0xe0, 0x38, 0x12, 0x48, 0x90, 0x0c,
            0xee, 0xbf, 0x95, 0x31, 0xff, 0xc7, 0xf5, 0xb9, 0x4f, 0x18, 0x57, 0x46, 0x37, 0xbb,
            0xce, 0x7b, 0xa7, 0x26, 0x18, 0x5a, 0x3c, 0x41, 0xb2, 0x2e, 0xb7, 0x86, 0x51, 0xdc,
            0xf6, 0x26, 0x86, 0xf3, 0xc7, 0x96, 0x23, 0xed,
        ],
    );

    // Parse the generated image.
    let mut reader = Cursor::new(&data);
    let (new_header, new_footer, new_image_size) = avb::load_image(&mut reader).unwrap();
    let new_footer = new_footer.unwrap();

    assert_eq!(new_header, header);
    assert_eq!(new_footer, footer);
    assert_eq!(new_image_size, 28672);
}

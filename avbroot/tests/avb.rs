/*
 * SPDX-FileCopyrightText: 2023-2024 Andrew Gunnerson
 * SPDX-License-Identifier: GPL-3.0-only
 */

use std::{
    io::{Cursor, Read, Seek, Write},
    sync::atomic::AtomicBool,
};

use assert_matches::assert_matches;
use pkcs8::DecodePrivateKey;
use rsa::RsaPrivateKey;

use avbroot::{
    self,
    format::avb::{
        self, AlgorithmType, AppendedDescriptorMut, AppendedDescriptorRef,
        ChainPartitionDescriptor, Descriptor, Footer, HashDescriptor, HashTreeDescriptor, Header,
        KernelCmdlineDescriptor, PropertyDescriptor,
    },
    stream::SharedCursor,
};

fn get_test_key() -> RsaPrivateKey {
    let data = include_str!(concat!(
        env!("CARGO_WORKSPACE_DIR"),
        "/e2e/keys/TEST_KEY_DO_NOT_USE_avb.key",
    ));
    let passphrase = include_str!(concat!(
        env!("CARGO_WORKSPACE_DIR"),
        "/e2e/keys/TEST_KEY_DO_NOT_USE_avb.passphrase",
    ));

    RsaPrivateKey::from_pkcs8_encrypted_pem(data, passphrase.trim_end()).unwrap()
}

fn repeat_str(s: &str, max_len: usize) -> String {
    assert!(!s.is_empty());

    let mut result = s.repeat(max_len / s.len());
    result.push_str(&s[..max_len % s.len()]);

    result
}

fn repeat_array<const N: usize>(data: &[u8]) -> [u8; N] {
    assert!(!data.is_empty());

    let mut result = [0u8; N];

    for i in 0..N / data.len() {
        result[i * data.len()..][..data.len()].copy_from_slice(data);
    }

    let remain = N % data.len();
    result[N - remain..].copy_from_slice(&data[..remain]);

    result
}

#[test]
fn round_trip_root_image() {
    let mut header = Header {
        required_libavb_version_major: 1,
        required_libavb_version_minor: 0,
        algorithm_type: AlgorithmType::Sha256Rsa4096,
        hash: vec![],       // autogenerated
        signature: vec![],  // autogenerated
        public_key: vec![], // autogenerated
        public_key_metadata: vec![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ],
        descriptors: vec![
            Descriptor::Property(PropertyDescriptor {
                key: "foobar".to_owned(),
                value: b"Invalid UTF-8: \xFF".to_vec(),
            }),
            Descriptor::HashTree(HashTreeDescriptor {
                dm_verity_version: 1,
                image_size: 4096,
                tree_offset: 0,
                tree_size: 2048,
                data_block_size: 4096,
                hash_block_size: 4096,
                fec_num_roots: 1,
                fec_offset: 2048,
                fec_size: 2048,
                hash_algorithm: "sha512".to_owned(),
                partition_name: "hashtreed_partition".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(8),
                root_digest: [0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10].repeat(8),
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
            Descriptor::Hash(HashDescriptor {
                image_size: 6,
                hash_algorithm: "sha256".to_owned(),
                partition_name: "hashed_partition".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(4),
                root_digest: [0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10].repeat(4),
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
            Descriptor::KernelCmdline(KernelCmdlineDescriptor {
                flags: 1,
                cmdline: "foobar".to_owned(),
            }),
            Descriptor::ChainPartition(ChainPartitionDescriptor {
                rollback_index_location: 1,
                partition_name: "chained_partition".to_owned(),
                public_key: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(129),
                flags: 0xfedcba98,
                reserved: repeat_array(&[0x76, 0x54, 0x32, 0x10, 0xfe, 0xdc, 0xba, 0x98]),
            }),
        ],
        rollback_index: 1677974400,
        flags: 0,
        rollback_index_location: 0,
        release_string: repeat_str("MaxLength", 48),
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };

    // Sign the header.
    let key = get_test_key();
    header.sign(&key).unwrap();
    assert_eq!(header.verify().unwrap().unwrap(), key.to_public_key());

    // Write vbmeta structures.
    let mut writer = Cursor::new(Vec::new());
    avb::write_root_image(&mut writer, &header, 64).unwrap();
    let data = writer.into_inner();

    // Verify checksum of the output.
    assert_eq!(
        ring::digest::digest(&ring::digest::SHA512, &data).as_ref(),
        [
            0xc4, 0xa5, 0xda, 0x3e, 0x09, 0xa2, 0xc8, 0x70, 0xcb, 0xf0, 0x96, 0x79, 0x0e, 0x1e,
            0x80, 0xae, 0x5e, 0x37, 0x81, 0x27, 0x24, 0xc3, 0x6c, 0xa9, 0x42, 0x9e, 0x2c, 0xb1,
            0x81, 0xad, 0xce, 0xee, 0x8d, 0x4f, 0x76, 0x45, 0x54, 0xc1, 0x31, 0x6a, 0xa7, 0x81,
            0x5c, 0x59, 0xa8, 0xe8, 0x76, 0xab, 0xed, 0x5b, 0x07, 0x07, 0x38, 0xdd, 0x09, 0x86,
            0x05, 0x39, 0x23, 0x2d, 0x7b, 0xcc, 0x57, 0x06,
        ],
    );

    // Parse the generated image.
    let mut reader = Cursor::new(&data);
    let (new_header, new_footer, new_image_size) = avb::load_image(&mut reader).unwrap();
    assert_matches!(new_footer, None);

    assert_eq!(new_header, header);
    assert_eq!(new_image_size, data.len() as u64);
}

#[test]
fn round_trip_appended_hash_image() {
    let image_size = 12288;
    let raw_data = b"foobar";
    let mut header = Header {
        required_libavb_version_major: 1,
        required_libavb_version_minor: 0,
        algorithm_type: AlgorithmType::Sha256Rsa4096,
        hash: vec![],       // autogenerated
        signature: vec![],  // autogenerated
        public_key: vec![], // autogenerated
        public_key_metadata: vec![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ],
        descriptors: vec![
            Descriptor::Property(PropertyDescriptor {
                key: "foobar".to_owned(),
                value: b"Invalid UTF-8: \xFF".to_vec(),
            }),
            Descriptor::Hash(HashDescriptor {
                image_size: raw_data.len() as u64,
                hash_algorithm: "sha256".to_owned(),
                partition_name: "vbmeta_appended_hash".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(4),
                root_digest: vec![], // autogenerated
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
        ],
        rollback_index: 1677974400,
        flags: 0,
        rollback_index_location: 0,
        release_string: repeat_str("MaxLength", 48),
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };
    let mut footer = Footer {
        version_major: 1,
        version_minor: 0,
        original_image_size: 0, // autogenerated
        vbmeta_offset: 0,       // autogenerated
        vbmeta_size: 0,         // autogenerated
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };

    let mut writer = Cursor::new(Vec::new());
    let cancel_signal = AtomicBool::new(false);

    // Write the raw partition data.
    writer.write_all(raw_data).unwrap();

    // Regenerate the raw image digest.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(_) => panic!("Expected hash descriptor"),
        AppendedDescriptorMut::Hash(d) => {
            writer.rewind().unwrap();
            d.update(&mut writer, &cancel_signal).unwrap();
        }
    }

    // Verify the raw image digest.
    match header.appended_descriptor().unwrap() {
        AppendedDescriptorRef::HashTree(_) => panic!("Expected hash descriptor"),
        AppendedDescriptorRef::Hash(d) => {
            writer.rewind().unwrap();
            d.verify(&mut writer, &cancel_signal).unwrap();
        }
    }

    // Sign the header.
    let key = get_test_key();
    header.sign(&key).unwrap();
    assert_eq!(header.verify().unwrap().unwrap(), key.to_public_key());

    // Write vbmeta structures.
    avb::write_appended_image(&mut writer, &header, &mut footer, image_size).unwrap();
    let data = writer.into_inner();

    // Verify checksum of the output.
    assert_eq!(
        ring::digest::digest(&ring::digest::SHA512, &data).as_ref(),
        [
            0x09, 0x98, 0x0c, 0x9d, 0x11, 0x50, 0xde, 0xb1, 0x55, 0x3b, 0x00, 0x76, 0xbe, 0x25,
            0xfd, 0xe6, 0x46, 0x22, 0xbd, 0x9a, 0x05, 0x86, 0xea, 0x07, 0x4d, 0x8f, 0x7b, 0x15,
            0x36, 0x20, 0x0d, 0xf0, 0x7e, 0x96, 0xd2, 0x58, 0xde, 0xf2, 0xa6, 0x91, 0x6d, 0x01,
            0x7b, 0x03, 0x96, 0x70, 0xf8, 0x3b, 0x76, 0x74, 0xf0, 0xbf, 0x47, 0xe0, 0xd2, 0xd4,
            0x5d, 0xbf, 0xb7, 0x9c, 0xf5, 0xf8, 0xaf, 0x3c,
        ],
    );

    // Parse the generated image.
    let mut reader = Cursor::new(&data);
    let (new_header, new_footer, new_image_size) = avb::load_image(&mut reader).unwrap();
    let new_footer = new_footer.unwrap();

    assert_eq!(new_header, header);
    assert_eq!(new_footer, footer);
    assert_eq!(new_image_size, image_size);
}

#[test]
fn round_trip_appended_hash_tree_image() {
    let image_size = 28672;
    let raw_data: [u8; 8192] = repeat_array(b"foobar");
    let mut header = Header {
        required_libavb_version_major: 1,
        required_libavb_version_minor: 0,
        algorithm_type: AlgorithmType::Sha256Rsa4096,
        hash: vec![],       // autogenerated
        signature: vec![],  // autogenerated
        public_key: vec![], // autogenerated
        public_key_metadata: vec![
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
            0x0e, 0x0f,
        ],
        descriptors: vec![
            Descriptor::Property(PropertyDescriptor {
                key: "foobar".to_owned(),
                value: b"Invalid UTF-8: \xFF".to_vec(),
            }),
            Descriptor::HashTree(HashTreeDescriptor {
                dm_verity_version: 1,
                image_size: raw_data.len() as u64,
                tree_offset: 0, // autogenerated
                tree_size: 0,   // autogenerated
                data_block_size: 4096,
                hash_block_size: 4096,
                fec_num_roots: 2,
                fec_offset: 0, // autogenerated
                fec_size: 0,   // autogenerated
                hash_algorithm: "sha256".to_owned(),
                partition_name: "vbmeta_appended_hash_tree".to_owned(),
                salt: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef].repeat(4),
                root_digest: vec![], // autogenerated
                flags: 0,
                reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
            }),
        ],
        rollback_index: 1677974400,
        flags: 0,
        rollback_index_location: 0,
        release_string: repeat_str("MaxLength", 48),
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };
    let mut footer = Footer {
        version_major: 1,
        version_minor: 0,
        original_image_size: 0, // autogenerated
        vbmeta_offset: 0,       // autogenerated
        vbmeta_size: 0,         // autogenerated
        reserved: repeat_array(&[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]),
    };

    let mut writer = SharedCursor::default();
    let cancel_signal = AtomicBool::new(false);

    // Write the raw partition data.
    writer.write_all(&raw_data).unwrap();

    // Generate and write the hash tree and FEC data.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(d) => {
            d.update(&writer, &writer, None, &cancel_signal).unwrap();
        }
        AppendedDescriptorMut::Hash(_) => panic!("Expected hash tree descriptor"),
    }

    // Verify the hash tree and FEC data.
    match header.appended_descriptor_mut().unwrap() {
        AppendedDescriptorMut::HashTree(d) => {
            d.verify(&writer, &cancel_signal).unwrap();
        }
        AppendedDescriptorMut::Hash(_) => panic!("Expected hash tree descriptor"),
    }

    // Sign the header.
    let key = get_test_key();
    header.sign(&key).unwrap();
    assert_eq!(header.verify().unwrap().unwrap(), key.to_public_key());

    // Write vbmeta structures.
    avb::write_appended_image(&mut writer, &header, &mut footer, image_size).unwrap();
    let mut data = Vec::new();
    writer.rewind().unwrap();
    writer.read_to_end(&mut data).unwrap();

    // Verify checksum of the output.
    assert_eq!(
        ring::digest::digest(&ring::digest::SHA512, &data).as_ref(),
        [
            0xd6, 0x69, 0x19, 0x6a, 0x36, 0xc8, 0x1c, 0xe9, 0xc4, 0x85, 0xbe, 0xff, 0x43, 0xb1,
            0x9f, 0xd4, 0x1d, 0x6c, 0xf9, 0xd2, 0xf3, 0xa6, 0x5f, 0x66, 0x41, 0xd5, 0xf3, 0xfd,
            0x28, 0xdb, 0x14, 0x67, 0xc6, 0xa8, 0xef, 0xc4, 0xd4, 0x67, 0x6c, 0xb8, 0x66, 0xbb,
            0x56, 0x5a, 0x4a, 0xf5, 0xd8, 0x92, 0x7c, 0x42, 0xbc, 0x47, 0xdb, 0x94, 0x38, 0x15,
            0x4b, 0x2d, 0xd0, 0x28, 0x1f, 0xd1, 0x45, 0xa9,
        ],
    );

    // Parse the generated image.
    let mut reader = Cursor::new(&data);
    let (new_header, new_footer, new_image_size) = avb::load_image(&mut reader).unwrap();
    let new_footer = new_footer.unwrap();

    assert_eq!(new_header, header);
    assert_eq!(new_footer, footer);
    assert_eq!(new_image_size, image_size);
}
